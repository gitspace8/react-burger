## Нюансы по работе 

1. Задание "Доработка интерфейса навигации по ингредиентам из проектной работы  можно реализовать используя библиотеку react-intersection-observer , но можно не через неё, а напрямую через вычисление расстояний используя getBoundingClientRect, т.к. intersection-observer дает информацию какой элемент отображается на странице, а не какой элемент ближе к началу списка
2. В конструктор можно добавить несколько одинаковых ингредиентов. При этом у элементов в списке должен быть уникальный key, что бы реакт понимал какие элементы добавляются, удаляются или перемещаются. Использовать индекс массива или id ингредиента не получится, подставлять Math.Random для key тоже плохая идея. Поэтому при добавлении ингредиента в конструктор нужно в объект добавляемого ингредиента добавлять ключ, который можно использовать для key. Этот ключ можно создать используя например https://www.npmjs.com/package/uuid/  Таким образом у каждого ингредиента в конструкторе будет свой уникальный ключ, который можно использовать для key. Без этого не будет корректно работать библиотека ReactDND. Ключ должен генерироваться в экшене (либо в экшен креейторе либо в prepare при использовании слайсов), а не в редьюсере, т.к. редьюсер должен быть чистой функцией
3. В сторе ингредиенты конструктора лучше хранить не в одном массиве (и булки и начинку), а разделить. В отдельном поле bun хранить выбранную булку и отдельно хранить начинку бургера в массиве в поле ingredients:
   JS { bun: null, ingredients: [] }
   Так легче взаимодействовать с хранилищем
4. Не пишите все в одном редьюсере, на каждую задачу (загрузка ингредиентов, работа конструктора, отправка заказа, открытие окна в попапе) свой редьюсер
5. Перетаскивание и сортировка элементов реализуется так же как в примере из документации из ReactDND
5.1 https://react-dnd.github.io/react-dnd/examples/dustbin/single-target
5.2 https://react-dnd.github.io/react-dnd/examples/sortable/simple
6. ри сортировке в редьюсере поменять два элемента местами можно с помощью splice
   JS const ingredients = [...state.ingredients]; ingredients.splice(toIndex, 0, ingredients.splice(fromIndex, 1)[0]); 
7. На втором этапе работы (при переносе стейта в redux) лучше расчет полной стоимости разместить просто в компоненте (или селекторе или в мемоизированном селекторе), а не описывать логику в redux
   JS const totalPrice = useMemo(()=> { return **расчет стоимости** }, [burgersData])
   Аналогично и со счетчиками ингредиентов, можно не размещать логику счетчиков в редьюсере, а поместить в компоненте
8. И ещё немного доп. информации по селекторам в redux
   В теории не очень много внимания уделено селекторам. Селектор - это функция, которая извлекает из стора нужные данные.
   Пример селектора:

const getTotaPrice = (store) => {
    return store.cart.items.reduce((acc, item)=> acc + item.price, 0)
}

Эту функцию передаем в useSelector, или при использовании mapStateToProps так же можно использовать функцию селектор:

const mapStateToProps = (store, ownProps) => {
    return {
        step: getStep(store),
        totalPrice: getTotaPrice(store),
    };
};

Функции селекторы нужны, что бы наши компоненты не знали как устроен внутри стор, и логика выборки данных из стора была вынесена из самих компонентов и могла переиспользоваться
